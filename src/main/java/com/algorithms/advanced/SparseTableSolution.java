package com.algorithms.advanced;

/**
 * <p>
 * Sparse table is a solution for very fast queries on preferably immutable
 * range of elements. The array is consumed to generate a set of static data
 * mapping. A known use case is a combination with euler tour and RMQ to answer
 * O(1) time to queries.
 * </p>
 * <p>
 * Sparse table is a method to generate a table of preproccessed answers to a
 * query, where answers are generated for the size of 2^p elements. Naturally, p
 * will be in range of 0...log(n). Later this table will be used as a lookup
 * table for answering queries in constant time.
 * </p>
 * <p>
 * Sparse table are generally constructed in tabular manner. *(Tabular meaning
 * buttom-up, opposite of memoized!)
 * </p>
 * <p>
 * Let's say that the for an array of length 8; the applicable powers of 2 is
 * 2^0, 2^1, 2^2 and 2^3. This means, the sparse table will be generated by
 * taking the result of a query on 2^1, 2^2 and 2^3 number of elements
 * consecutively. But, there is a trick. Each repetition of query result is used
 * to fill the latter query, thus generation of results are also speeded up.
 * Image that a frame of length 2 range i is traversing the original array at +1
 * rate. Each step will aggregate to
 * </p>
 * <p>
 * For example, for a query that is the sum of range; let the array be :
 * <q>array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</q>
 * </p>
 * <p>
 * Where sparse table is table[][];
 * <li>R0 : { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }</li>
 * <li>R1 : { 3, 5, 7, 9, 11, 13, 15, 17, 19 }</li>
 * <li>R2 : { 10, 14, 18, 22, 26, 30, 34 }</li>
 * <li>R3 : { 32, 40, 48, 56 }</li>
 * </p>
 * <p>
 * How do we find the values?
 * </p>
 * <ul>
 * <li>Iteration 0 : 2^0 = 1 : previous iteration step length = 0 since
 * range/power is 0. Thus;
 * <ul>
 * <li>table[0][0] = arr[0];</li>
 * <li>table[0][1] = arr[1];</li>
 * <li>table[0][2] = arr[2];...</li>
 * </ul>
 * </li>
 * <li>Iteration 1 : 2^1 = 2 : previous iteration step length = 1 since
 * range/power is 1. Thus;
 * <ul>
 * <li>table[1][0] = table[0][0] + table[0][1];</li>
 * <li>table[1][1] = table[0][1]+table[0][2];</li>
 * <li>table[1][2] = table[0][1]+table[0][2];...</li>
 * </ul>
 * <li>Iteration 2 : 2^2 = 4 : previous iteration step length = 2 since
 * range/power is 1. Thus;
 * <ul>
 * <li>table[2][0] = table[1][0] + table[0][2];</li>
 * <li>table[2][1] = table[1][1]+table[1][3];</li>
 * <li>table[1][2] = arr[2];...</li>
 * </ul>
 * </li>
 * </ul>
 * <p>
 * During a query on sparse table, it is required to determine the range of the
 * query, the max length possible in 2 range i within the found range, and
 * process the results from the findings by iteration to length - possible
 * range. As such for a query of range of sum between indices 2 to 7 would be:
 * <ul>
 * <li>Found range inclusive(2 to 7) = 6 elements of range</li>
 * <li>maximum possible range of 2^i is where i is 2; thus fetches R2. <i>this
 * is equal to floor(log(6)) = 4</i>.</li>
 * <li>length - possible range is 6-4=2, thus we will need to steps to
 * calculate</li>
 * <li>in R2, index 2 points to sum of elements from 2 to 5 in original array.
 * and index holds the sum of elements from 4 to 7. Thus, result = table[2][2]+
 * query(6,7), hence recursive</li>
 * </ul>
 * <p>
 * <p>
 * For a different query, type of process will differ but the main logic will be
 * applied
 * <p>
 * 
 * @author Ozan Aksoy
 *
 */
public class SparseTableSolution {

	// lookup[i][j] is going to store minimum
	// value in arr[i..j]. Ideally lookup table
	// size should not be fixed and should be
	// determined using n Log n. It is kept
	// constant to keep code simple.
	static int[][] lookup;

	// Fills lookup array lookup[][] in bottom up manner.
	static void buildSparseTable(int arr[], int n) {

		lookup = new int[n][n];

		// Initialize M for the intervals with length 1
		for (int i = 0; i < n; i++)
			lookup[i][0] = arr[i];

		// Compute values from smaller to bigger intervals
		for (int j = 1; (1 << j) <= n; j++) {

			// Compute minimum value for all intervals with
			// size 2^j
			for (int i = 0; (i + (1 << j) - 1) < n; i++) {

				// For arr[2][10], we compare arr[lookup[0][7]]
				// and arr[lookup[3][10]]
				if (lookup[i][j - 1] < lookup[i + (1 << (j - 1))][j - 1])
					lookup[i][j] = lookup[i][j - 1];
				else
					lookup[i][j] = lookup[i + (1 << (j - 1))][j - 1];
			}
		}
	}

	// Returns minimum of arr[L..R]
	static int query(int L, int R) {

		// Find highest power of 2 that is smaller
		// than or equal to count of elements in given
		// range. For [2, 10], j = 3
		int j = (int) Math.log(R - L + 1);

		// Compute minimum of last 2^j elements with first
		// 2^j elements in range.
		// For [2, 10], we compare arr[lookup[0][3]] and
		// arr[lookup[3][3]],
		if (lookup[L][j] <= lookup[R - (1 << j) + 1][j])
			return lookup[L][j];

		else
			return lookup[R - (1 << j) + 1][j];
	}

	// Driver program
	public static void main(String[] args) {
		int a[] = { 7, 2, 3, 0, 5, 10, 3, 12, 18 };
		int n = a.length;

		buildSparseTable(a, n);

		System.out.println(query(0, 4));
		System.out.println(query(4, 7));
		System.out.println(query(7, 8));

	}

}// End of Class
