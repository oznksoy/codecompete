package com.algorithms.advanced;

import java.util.ArrayList;
import java.util.List;

/**
 * <p>
 * Sparse table is a solution for very fast queries on preferably immutable
 * range of elements. The array is consumed to generate a set of static data
 * mapping. A known use case is a combination with euler tour and RMQ to answer
 * O(1) time to queries.
 * </p>
 * <p>
 * Sparse table is a method to generate a table of preproccessed answers to a
 * query, where answers are generated for the size of 2^p elements. Naturally, p
 * will be in range of 0...log(n). Later this table will be used as a lookup
 * table for answering queries in constant time.
 * </p>
 * <p>
 * Sparse table are generally constructed in tabular manner. *(Tabular meaning
 * buttom-up, opposite of memoized!)
 * </p>
 * <p>
 * Let's say that the for an array of length 8; the applicable powers of 2 is
 * 2^0, 2^1, 2^2 and 2^3. This means, the sparse table will be generated by
 * taking the result of a query on 2^1, 2^2 and 2^3 number of elements
 * consecutively. But, there is a trick. Each repetition of query result is used
 * to fill the latter query, thus generation of results are also speeded up.
 * Imagine that a frame of length 2 range i is traversing the original array at
 * +1 rate. Each step will aggregate to the corresponding frame at the
 * consecutive index.
 * </p>
 * <p>
 * For example, for a query that is the sum of range; let the array be :
 * <q>array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</q>
 * </p>
 * <p>
 * Where sparse table is table[][];
 * <li>R0 : { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }</li>
 * <li>R1 : { 3, 5, 7, 9, 11, 13, 15, 17, 19 }</li>
 * <li>R2 : { 10, 14, 18, 22, 26, 30, 34 }</li>
 * <li>R3 : { 36, 44, 52 }</li>
 * </p>
 * <p>
 * How do we find the values?
 * </p>
 * <ul>
 * <li>Iteration 0 : 2^0 = 1 : since range/power is 2^0 = 1. Thus;
 * <ul>
 * <li>table[0][0] = arr[0];</li>
 * <li>table[0][1] = arr[1];</li>
 * <li>table[0][2] = arr[2];...</li>
 * </ul>
 * </li>
 * <li>Iteration 1 : 2^1 = 2 : previous iteration step length = 1 since previous
 * range is 2^0. Thus;
 * <ul>
 * <li>table[1][0] = table[0][0] + table[0][1];</li>
 * <li>table[1][1] = table[0][1] + table[0][2];</li>
 * <li>table[1][2] = table[0][1] + table[0][2];...</li>
 * </ul>
 * <li>Iteration 2 : 2^2 = 4 : previous iteration step length = 2 since
 * range/power is 2^1. Thus;
 * <ul>
 * <li>table[2][0] = table[1][0] + table[1][2];</li>
 * <li>table[2][1] = table[1][1] + table[1][3];</li>
 * <li>table[2][2] = table[1][2] + table[1][4];...</li>
 * </ul>
 * </li> *
 * <li>Iteration 2 : 2^3 = 8 : previous iteration step length = 4 since
 * range/power is 2^2. Thus;
 * <ul>
 * <li>table[3][0] = table[2][0] + table[2][4];</li>
 * <li>table[3][1] = table[2][1] + table[2][5];</li>
 * <li>table[3][2] = table[2][2] + table[2][6];</li>
 * </ul>
 * </li>
 * </ul>
 * <p>
 * During a query on sparse table, it is required to determine the range of the
 * query, the max length possible in 2 range i within the found range, and
 * process the results from the findings by iteration to length - possible
 * range. As such for a query of range of sum between indices 2 to 7 would be:
 * <ul>
 * <li>Found range inclusive(2 to 7) = 6 elements of range</li>
 * <li>maximum possible range of 2^i is where i is 2; thus fetches R2. <i>this
 * is equal to floor(log(6)) = 4</i>.</li>
 * <li>length - possible range is 6-4=2, thus we will need to steps to
 * calculate</li>
 * <li>in R2, index 2 points to sum of elements from 2 to 5 in original array.
 * and index holds the sum of elements from 4 to 7. Thus, result = table[2][2]+
 * query(6,7), hence recursive</li>
 * </ul>
 * <p>
 * <p>
 * For a different query, type of process will differ but the main logic will be
 * applied
 * <p>
 * 
 * @author Ozan Aksoy
 *
 */
public class SparseTableSolution {

	public static void main(String[] args) {

		SparseTableSolution solution = new SparseTableSolution();
		solution.test();

	}// End of Main

	private class SparseTable {

		List<Integer> sparseTable[];

		public SparseTable(int[] array) {
			this.build(array);
		}

		private void build(int[] array) {

			int n = array.length;
			sparseTable = new ArrayList[n];

			sparseTable[0] = new ArrayList<Integer>(n);

			for (int val : array) {
				sparseTable[0].add(val);
			}

			for (int i = 1; Math.pow(2, i) <= n; i++) { // counts power of 2 below n
				// int step = 1 << i;
				sparseTable[i] = new ArrayList<Integer>();
				for (int j = 0; j + (1 << i) - 1 < n; j++) { // 1<<i = Math.pow(2,i);
					int sum = sparseTable[i - 1].get(j) + sparseTable[i - 1].get(j + (1 << (i - 1)));
					sparseTable[i].add(sum);
				}
			}

		}// End of Method

		public int query(int from, int to) {

			if (from == to) {
				return sparseTable[0].get(to);
			} else if (to < from) { // swap indexes if to is smaller than from
				to += from;
				from = to - from;
				to -= from;
			}

			int sum = 0;
			int diff = to - from + 1; // inclusive difference
			int level = Integer.numberOfTrailingZeros(Integer.highestOneBit(diff));

			if (diff - (1 << level) == 0) {
				sum = sparseTable[level].get(from);
			} else {
				int belowFrom = to + 1 - diff + (1 << level);
				sum = sparseTable[level].get(from) + query(belowFrom, to);
			}

			return sum;
		}

	}// End of Inner Class

	public void test() {
		for (int n = 10; n <= 100; n++) {
			int[] array = generateCheckSumArray(n, 1);
			completeControl(array);
		}
	}

	public void completeControl(int array[]) {
		for (int from = 0; from < array.length - 1; from++) {
			for (int to = from + 1; to < array.length; to++) {
				int expected = calculateSumAsNaive(array, from, to);
				SparseTable sparseTable = new SparseTable(array);
				int actual = sparseTable.query(from, to);
				if (expected != actual) {
					System.err.println("Fail!");
					System.err.println("Expected : " + expected);
					System.err.println("Actual : " + actual);
				}

			}
		}
	}

	public int[] generateCheckSumArray(int n, int spread) {
		int[] array = new int[n];
		for (int i = 0; i < array.length; i++) {
			array[i] = i + spread;
		}
		return array;
	}// End of Method

	public int calculateSumAsNaive(int[] array, int from, int to) {

		int sum = 0;
		for (int i = from; i <= to && i < array.length; i++) {
			sum += array[i];
		}
		return sum;

	}// End of Method

}// End of Class
